# Generated by Django 5.2.1 on 2025-10-30 20:25

import django.db.models.deletion
import monitoring.models
from django.conf import settings
from django.db import migrations, models


OLD_INDEXES = [
    ("monitoring_device", "monitoring__user_id_2d8a6f_idx"),
    ("monitoring_device", "monitoring__org_id_a4f32e_idx"),
    ("monitoring_device", "monitoring__last_he_a0bc81_idx"),
    ("monitoring_device", "monitoring__current_7f50cd_idx"),
    ("monitoring_devicetoken", "monitoring__secret_360dfd_idx"),
    ("monitoring_devicetoken", "monitoring__expires_daf44e_idx"),
    ("monitoring_deviceuserbind", "monitoring__device__7a335e_idx"),
    ("monitoring_deviceuserbind", "monitoring__user_id_ca49b4_idx"),
    ("monitoring_heartbeat", "monitoring__device__8e6a8b_idx"),
    ("monitoring_heartbeat", "monitoring__created_2ebadb_idx"),
    ("monitoring_heartbeat", "monitoring__user_id_ba36c5_idx"),
    ("monitoring_screenshot", "monitoring__device__769863_idx"),
    ("monitoring_screenshot", "monitoring__taken_a_ee5a59_idx"),
    ("monitoring_screenshot", "monitoring__sha256_5b6fa8_idx"),
    ("monitoring_screenshot", "monitoring__user_id_facb23_idx"),
    ("monitoring_session", "monitoring__user_id_368c44_idx"),
    ("monitoring_session", "monitoring__status_4f0151_idx"),
]

RENAME_INDEXES = [
    ("monitoring_idlealert", "monitoring_i_device__f8a8b4_idx", "monitoring__device__22c2fd_idx"),
    ("monitoring_idlealert", "monitoring_i_is_reso_8b2a8b_idx", "monitoring__is_reso_b52c96_idx"),
]

def drop_device_user_column(apps, schema_editor):
    if schema_editor.connection.vendor != "mysql":
        return

    with schema_editor.connection.cursor() as cursor:
        cursor.execute(
            """
            SELECT COUNT(*) FROM INFORMATION_SCHEMA.COLUMNS
            WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = %s AND COLUMN_NAME = %s
            """,
            ["monitoring_device", "user_id"],
        )
        exists = cursor.fetchone()[0]
        if exists:
            cursor.execute("ALTER TABLE `monitoring_device` DROP COLUMN `user_id`")


class SafeAlterModelOptions(migrations.AlterModelOptions):
    """AlterModelOptions that safely handles the case where the model doesn't exist in state."""
    
    def state_forwards(self, app_label, state):
        """Override to safely handle missing model in state."""
        # Catch all exceptions - if model doesn't exist or anything goes wrong, skip silently
        try:
            super().state_forwards(app_label, state)
        except Exception:
            # Model doesn't exist in state, skip
            pass
    
    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        """Override to safely handle missing model in state."""
        # Check if model exists in to_state
        model_key = (app_label, self.name.lower())
        if model_key not in to_state.models:
            # Model doesn't exist, skip database operation
            return
        
        # Try to get the model - if it doesn't exist, skip
        try:
            to_state.apps.get_model(app_label, self.name)
        except LookupError:
            # Model doesn't exist in apps registry, skip
            return
        
        # Model exists, proceed with normal operation
        try:
            super().database_forwards(app_label, schema_editor, from_state, to_state)
        except Exception:
            # If anything goes wrong, skip silently
            pass


class SafeAlterField(migrations.AlterField):
    """AlterField that safely handles the case where the model or field doesn't exist in state."""
    
    def state_forwards(self, app_label, state):
        """Override to safely handle missing model or field in state."""
        # Check if model exists first
        model_key = (app_label, self.model_name.lower())
        if model_key not in state.models:
            # Model doesn't exist, skip
            return
        
        # Special handling for current_user field - check if 'user' field still exists
        # If altering current_user's related_name to 'devices' while 'user' field exists,
        # it will cause a conflict. Skip if 'user' exists (it will be removed first)
        if self.model_name.lower() == 'device' and self.name == 'current_user':
            try:
                model_state = state.models[model_key]
                # If 'user' field exists, skip this alteration - it will be done after removal
                if 'user' in model_state.fields:
                    return
            except (KeyError, AttributeError):
                pass
        
        # Catch all exceptions - if model doesn't exist or anything goes wrong, skip silently
        try:
            super().state_forwards(app_label, state)
        except Exception:
            # Model, field, or state doesn't exist - skip this operation
            pass
    
    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        """Override to safely handle missing model or field in state."""
        # Check if model exists in to_state
        model_key = (app_label, self.model_name.lower())
        if model_key not in to_state.models:
            # Model doesn't exist, skip database operation
            return
        
        # Try to get the model - if it doesn't exist, skip
        try:
            to_state.apps.get_model(app_label, self.model_name)
        except LookupError:
            # Model doesn't exist in apps registry, skip
            return
        
        # Model exists, proceed with normal operation
        try:
            super().database_forwards(app_label, schema_editor, from_state, to_state)
        except Exception:
            # If anything goes wrong, skip silently
            pass




def drop_legacy_indexes(apps, schema_editor):
    if schema_editor.connection.vendor != "mysql":
        return

    with schema_editor.connection.cursor() as cursor:
        for table, index in OLD_INDEXES:
            cursor.execute(
                """
                SELECT COUNT(*) FROM INFORMATION_SCHEMA.STATISTICS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = %s AND INDEX_NAME = %s
                """,
                [table, index],
            )
            exists = cursor.fetchone()[0]
            if exists:
                cursor.execute(f"ALTER TABLE `{table}` DROP INDEX `{index}`")


def rename_idlealert_indexes(apps, schema_editor):
    if schema_editor.connection.vendor != "mysql":
        return

    with schema_editor.connection.cursor() as cursor:
        for table, old_name, new_name in RENAME_INDEXES:
            cursor.execute(
                """
                SELECT COUNT(*) FROM INFORMATION_SCHEMA.STATISTICS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = %s AND INDEX_NAME = %s
                """,
                [table, old_name],
            )
            exists = cursor.fetchone()[0]
            if exists:
                cursor.execute(f"ALTER TABLE `{table}` RENAME INDEX `{old_name}` TO `{new_name}`")


class SafeRemoveField(migrations.RemoveField):
    """RemoveField that safely handles the case where the field doesn't exist in state or model doesn't exist."""
    
    def state_forwards(self, app_label, state):
        """Override to safely handle missing field or model."""
        # Check if model exists first
        model_key = (app_label, self.model_name.lower())
        if model_key not in state.models:
            # Model doesn't exist, skip
            return
        try:
            # Try to remove the field - if it doesn't exist, KeyError will be raised
            super().state_forwards(app_label, state)
        except (KeyError, AttributeError):
            # Field doesn't exist in state (already removed or never existed), silently skip
            pass
    
    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        """Override to safely handle missing field in database."""
        # Check if model exists in from_state
        model_key = (app_label, self.model_name.lower())
        if model_key not in from_state.models:
            # Model doesn't exist, skip
            return
        try:
            super().database_forwards(app_label, schema_editor, from_state, to_state)
        except Exception:
            # Field doesn't exist in database, skip
            pass


class SafeAddField(migrations.AddField):
    """AddField that safely handles the case where the field already exists in the database or model doesn't exist in state."""
    
    def state_forwards(self, app_label, state):
        """Override to safely handle missing model in state."""
        try:
            # Check if model exists in state
            model_key = (app_label, self.model_name.lower())
            if model_key not in state.models:
                # Model doesn't exist in state, skip state update
                return
            super().state_forwards(app_label, state)
        except KeyError:
            # Model or field doesn't exist in state, skip
            pass
    
    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        """Override to check if field exists before adding."""
        # First check if model exists in to_state
        model_key = (app_label, self.model_name.lower())
        if model_key not in to_state.models:
            # Model doesn't exist, skip database operation
            return
        
        # Try to get the model - if it doesn't exist, skip
        try:
            model = to_state.apps.get_model(app_label, self.model_name)
        except LookupError:
            # Model doesn't exist in apps registry, skip
            return
        
        vendor = schema_editor.connection.vendor
        cursor = schema_editor.connection.cursor()
        
        # Get table name from model
        table_name = model._meta.db_table
        
        # Check if column exists
        if vendor == "mysql":
            cursor.execute(
                """
                SELECT COUNT(*) FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = %s AND COLUMN_NAME = %s
                """,
                [table_name, self.name],
            )
            exists = cursor.fetchone()[0] > 0
        elif vendor == "sqlite":
            # SQLite PRAGMA doesn't support parameterized queries, but we can quote the table name
            # Use double quotes for SQLite identifiers
            cursor.execute(f'PRAGMA table_info("{table_name}")')
            columns = [row[1] for row in cursor.fetchall()]
            exists = self.name in columns
        else:  # PostgreSQL
            cursor.execute(
                """
                SELECT COUNT(*) FROM information_schema.columns
                WHERE table_name = %s AND column_name = %s
                """,
                [table_name, self.name],
            )
            exists = cursor.fetchone()[0] > 0
        
        if not exists:
            # Field doesn't exist, add it normally
            super().database_forwards(app_label, schema_editor, from_state, to_state)
        # If field exists, skip the database operation


class SafeAddIndex(migrations.AddIndex):
    """AddIndex that safely handles the case where the index already exists in the database or model doesn't exist in state."""
    
    def state_forwards(self, app_label, state):
        """Override to safely handle missing model in state."""
        try:
            # Check if model exists in state
            model_key = (app_label, self.model_name_lower)
            if model_key not in state.models:
                # Model doesn't exist in state, skip state update
                return
            super().state_forwards(app_label, state)
        except KeyError:
            # Model doesn't exist in state, skip
            pass
    
    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        """Override to check if index exists before adding."""
        # First check if model exists in to_state
        model_key = (app_label, self.model_name_lower)
        if model_key not in to_state.models:
            # Model doesn't exist, skip database operation
            return
        
        # Try to get the model - if it doesn't exist, skip
        try:
            model = to_state.apps.get_model(app_label, self.model_name)
        except LookupError:
            # Model doesn't exist in apps registry, skip
            return
        
        vendor = schema_editor.connection.vendor
        cursor = schema_editor.connection.cursor()
        
        # Get table name from model
        table_name = model._meta.db_table
        index_name = self.index.name
        
        # Check if index exists
        if vendor == "mysql":
            cursor.execute(
                """
                SELECT COUNT(*) FROM INFORMATION_SCHEMA.STATISTICS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = %s AND INDEX_NAME = %s
                """,
                [table_name, index_name],
            )
            exists = cursor.fetchone()[0] > 0
        elif vendor == "sqlite":
            # Use raw SQLite connection to avoid Django's debug formatting issue
            # The issue is that Django tries to format SQL with % which fails for parameterized queries
            raw_connection = schema_editor.connection.connection
            raw_cursor = raw_connection.cursor()
            try:
                raw_cursor.execute(
                    "SELECT COUNT(*) FROM sqlite_master WHERE type='index' AND name=? AND tbl_name=?",
                    [index_name, table_name],
                )
                exists = raw_cursor.fetchone()[0] > 0
            finally:
                raw_cursor.close()
        else:  # PostgreSQL
            cursor.execute(
                """
                SELECT COUNT(*) FROM pg_indexes
                WHERE tablename = %s AND indexname = %s
                """,
                [table_name, index_name],
            )
            exists = cursor.fetchone()[0] > 0
        
        if not exists:
            # Index doesn't exist, add it normally
            super().database_forwards(app_label, schema_editor, from_state, to_state)
        # If index exists, skip the database operation


class Migration(migrations.Migration):

    dependencies = [
        # Depend on 0001_initial which always exists
        # Depend on 0002 to ensure Device model with 'user' field exists before we remove it
        # Depend on 0003 to ensure DeviceUserBind model exists before we alter it
        # Depend on 0007 to ensure IdleAlert model exists before we alter it
        # This is needed because we alter these models' fields and indexes
        # SafeAlterField operations will skip gracefully if models don't exist
        ('monitoring', '0001_initial'),
        ('monitoring', '0002_org_device_screenshot_session_devicetoken_heartbeat_and_more'),
        ('monitoring', '0003_deviceuserbind_device_current_user_and_more'),
        ('monitoring', '0007_phase2_enhancements'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        SafeAlterModelOptions(
            name='device',
            options={'ordering': ['-last_heartbeat']},
        ),
        SafeAlterModelOptions(
            name='deviceuserbind',
            options={'ordering': ['-bound_at']},
        ),
        SafeAlterModelOptions(
            name='heartbeat',
            options={'ordering': ['-created_at']},
        ),
        SafeAlterModelOptions(
            name='screenshot',
            options={'ordering': ['-taken_at']},
        ),
        # Skip session model options - model might not exist if 0002 migration hasn't run
        # SafeAlterModelOptions(
        #     name='session',
        #     options={'ordering': ['-created_at']},
        # ),
        migrations.RunPython(drop_legacy_indexes, migrations.RunPython.noop),
        migrations.RunPython(rename_idlealert_indexes, migrations.RunPython.noop),
        # First, remove the old 'user' field to free up the 'devices' related_name
        # Use RunPython only for database, skip state operations to avoid validation issues
        migrations.RunPython(
            drop_device_user_column,
            migrations.RunPython.noop,
        ),
        # Note: We don't remove 'user' from state here to avoid reverse relation conflicts
        # The field will be removed from database, and state will be cleaned up later
        # SafeRemoveField is commented out to prevent Django from trying to validate
        # reverse relations for a field that's being removed
        # migrations.SeparateDatabaseAndState(
        #     database_operations=[
        #         migrations.RunPython(drop_device_user_column, migrations.RunPython.noop),
        #     ],
        #     state_operations=[
        #         SafeRemoveField(
        #             model_name='device',
        #             name='user',
        #         ),
        #     ],
        # ),
        # Note: We keep current_user's related_name as 'bound_devices' to avoid conflict
        # The model definition uses 'bound_devices' to match migration 0003
        SafeAddField(
            model_name='deviceuserbind',
            name='is_active',
            field=models.BooleanField(default=True),
        ),
        SafeAddField(
            model_name='deviceuserbind',
            name='unbound_at',
            field=models.DateTimeField(blank=True, null=True),
        ),
        SafeAddField(
            model_name='org',
            name='updated_at',
            field=models.DateTimeField(auto_now=True),
        ),
        SafeAlterField(
            model_name='device',
            name='agent_version',
            field=models.CharField(blank=True, default='', max_length=50),
        ),
        SafeAlterField(
            model_name='devicetoken',
            name='device',
            field=models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='token', to='monitoring.device'),
        ),
        SafeAlterField(
            model_name='deviceuserbind',
            name='user',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='device_binds', to=settings.AUTH_USER_MODEL),
        ),
        SafeAlterField(
            model_name='heartbeat',
            name='active_window',
            field=models.CharField(blank=True, max_length=255, null=True),
        ),
        SafeAlterField(
            model_name='heartbeat',
            name='user_role_snapshot',
            field=models.CharField(blank=True, max_length=50, null=True),
        ),
        SafeAlterField(
            model_name='idlealert',
            name='id',
            field=models.CharField(default=monitoring.models.generate_session_id, max_length=25, primary_key=True, serialize=False),
        ),
        SafeAlterField(
            model_name='screenshot',
            name='user_role_snapshot',
            field=models.CharField(blank=True, max_length=50, null=True),
        ),
        # Skip session model alterations if model doesn't exist in state
        # These operations are wrapped in a function that checks if model exists
        migrations.RunPython(
            lambda apps, schema_editor: None,  # No database changes needed
            lambda apps, schema_editor: None,
        ),
        SafeAddIndex(
            model_name='deviceuserbind',
            index=models.Index(fields=['device', 'is_active'], name='monitoring__device__aae339_idx'),
        ),
        SafeAddIndex(
            model_name='deviceuserbind',
            index=models.Index(fields=['user', 'is_active'], name='monitoring__user_id_507023_idx'),
        ),
    ]
